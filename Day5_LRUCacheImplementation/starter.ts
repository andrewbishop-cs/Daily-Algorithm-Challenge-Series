/**
 * Day 5 Challenge: LRU Cache Implementation
 * 
 * Warm up problems
 *  Leetcode 155 - Min Stack
 *  Leetcode 146 - LRU Cache
 *
 * Design an LRU cache that supports `get` and `put` in O(1) time.
 *
 * Use a combination of a hash map and a doubly‑linked list:
 * - `get(key)`   → return the value if present (else -1), mark key as most recently used
 * - `put(key,v)` → insert or update; if over capacity, evict the least recently used entry
 */
export class LRUCache {
    /**
     * @param capacity maximum number of entries in the cache
     */
    constructor(capacity: number) {
      // TODO: initialize your data structures
    }
  
    /**
     * Retrieve the value associated with `key` if it exists,
     * otherwise return -1. Marks `key` as recently used.
     */
    get(key: number): number {
      // TODO
      return -1;
    }
  
    /**
     * Insert or update `key` with the given `value`. If this insertion
     * causes the cache to exceed its capacity, evict the least recently
     * used key first.
     */
    put(key: number, value: number): void {
      // TODO
    }
  }
  